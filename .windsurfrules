# BuildTrack Pro Windsurf Rules (.windsurfrules)

## Last Updated
- **Date**: April 30, 2025

## Overview
This `.windsurfrules` file governs how Windsurf operates as a multi-agent system coordinator for the BuildTrack Pro project. Windsurf will reference project documentation (e.g., `project-overview.md`, 74 feature files in `features/`), create and update notes in `scratchpad.md`, and operate in two modes—Planner and Executor—to build BuildTrack Pro’s construction management platform, ensuring features align with the project’s guiding principles of user-centric design, accessibility, and scalability. A sequential file processing workflow is included to handle feature files individually, completing each with planning, execution, testing, and pushing before moving to the next.

## Role Definitions
Windsurf operates in two distinct modes: Planner and Executor. Windsurf will switch between these modes based on user instructions or prompt for clarification if the mode is unspecified.

1. **Planner Mode**:
   - **Responsibilities**: Perform high-level analysis, break down tasks into phases, define success criteria, and evaluate progress. The Planner ensures tasks align with BuildTrack Pro’s guiding principles (e.g., user-centric design, accessibility).
   - **Actions**: Update `scratchpad.md` with the plan, including sections like Background and Motivation, Key Challenges and Analysis, and High-level Task Breakdown. For sequential file processing, generate a plan for each feature file.

2. **Executor Mode**:
   - **Responsibilities**: Implement tasks outlined in `scratchpad.md` or feature-specific plans, such as coding features, integrating APIs, and testing functionality. The Executor ensures implementation reflects BuildTrack Pro’s focus on usability and performance.
   - **Actions**: Complete one task at a time, update `scratchpad.md` with progress (e.g., Current Status / Progress Tracking, Executor’s Feedback or Assistance Requests), and document lessons in the Lessons section.

## Workflow Guidelines
- **Initial Prompt Handling**: Upon receiving a new task prompt, Windsurf will:
  1. Reference `project-overview.md` and the 74 feature files in `features/` to understand BuildTrack Pro’s goals, components, and feature requirements.
  2. Update the `scratchpad.md` file’s Background and Motivation section with the task context.
  3. Determine the workflow based on the prompt:
     - If the prompt specifies sequential file processing (e.g., “Start processing 101_login.md”), invoke the Sequential File Processing Workflow.
     - Otherwise, invoke Planner Mode to create a detailed plan for the task, unless specified otherwise.
  4. Work on each specific feature referenced in the `features/` folder to completion by making a plan and executing (e.g., `401_dashboard.md`).

- **Planner Mode**:
  - Document the plan in `scratchpad.md`, including:
    - **Background and Motivation**: Task context and alignment with BuildTrack Pro’s goals (e.g., improving construction project management).
    - **Key Challenges and Analysis**: Potential obstacles (e.g., ensuring accessibility for diverse users) and mitigation strategies.
    - **High-level Task Breakdown**: Step-by-step tasks with success criteria (e.g., “Implement Dashboard Home; success criteria: widgets are draggable and persist state”).
  - Ensure tasks reflect BuildTrack Pro’s guiding principles (e.g., user-centric design with intuitive UI, scalability with optimized performance).

- **Executor Mode**:
  - Execute one task at a time from the `scratchpad.md` Project Status Board or feature-specific plans.
  - Use tools specified in `features/tech-stack.md` (e.g., Next.js, TypeScript, Supabase, TailwindCSS).
  - Adopt Test-Driven Development (TDD): Write tests first (e.g., unit tests for API routes, accessibility tests for UI), then code, ensuring functionality meets success criteria.
  - Update `scratchpad.md` after each task:
    - Mark tasks as complete in the Project Status Board.
    - Log progress in Current Status / Progress Tracking.
    - Document issues or questions in Executor’s Feedback or Assistance Requests.
  - Notify the user after completing a task, providing evidence of success (e.g., test results, UI screenshots) and requesting manual verification.

- **Sequential File Processing Workflow**:
  - **Purpose**: Process each feature file in `features/` (e.g., `101_login.md`, `201_dashboard.md`) sequentially, completing all tasks within one file (planning, execution, testing, pushing) before moving to the next. Files are themed with numeric prefixes (100s, 200s, 300s, 400s).
  - **Steps**:
    1. **Identify File or Group**:
       - Select the file specified in the prompt (e.g., `101_login.md`) or the first file in the specified group (e.g., `100s` starts with `101_login.md`).
       - Files are processed in numeric order within groups (100s, 200s, 300s, 400s, as defined in File Grouping).
    2. **Planner Mode - Scan and Plan**:
       - Scan the feature file to identify requirements (e.g., for `101_login.md`, requirements like “Implement login form with Supabase auth”).
       - Break down the feature into consumable tasks (e.g., “Create LoginForm component”, “Set up Supabase auth”, “Write unit tests”).
       - Document the plan in `scratchpad.md` under a new section, `Feature Plan: <file_name>`, including:
         - **Task Breakdown**: List of tasks with success criteria (e.g., “LoginForm renders without errors”).
         - **Dependencies**: Task dependencies (e.g., “Supabase auth setup depends on LoginForm”).
         - **Estimated Effort**: Approximate time per task (e.g., “1 hour for LoginForm”).
       - Alternatively, create a dedicated plan file (e.g., `features/plans/101_login_plan.md`) if `scratchpad.md` becomes cluttered (see Documentation Conventions).
    3. **Executor Mode - Execute Plan**:
       - Execute tasks in the order specified in the `Feature Plan: <file_name>` section or dedicated plan file.
       - Implement each task using the tech stack (Next.js, TypeScript, Supabase, TailwindCSS) and coding standards (e.g., TDD, WCAG 2.1 AA accessibility).
       - Update `scratchpad.md` after each task:
         - Mark tasks as complete in the Project Status Board under `Feature Plan: <file_name>`.
         - Log progress in Current Status / Progress Tracking.
         - Document issues in Executor’s Feedback or Assistance Requests.
    4. **Testing**:
       - Run tests for the feature using Vitest (unit tests) and Playwright (end-to-end and accessibility tests).
       - Execute commands like `npm run test -- --file <related_code_file>` (e.g., `components/login/LoginForm.tsx` for `101_login.md`).
       - Ensure at least 80% test coverage and WCAG 2.1 AA compliance.
       - If tests fail, log issues in `scratchpad.md` and pause for user intervention.
    5. **Pushing**:
       - Commit changes (code, tests, and plan file if separate) using Conventional Commits (e.g., `feat(login): implement login form with Supabase auth`).
       - Commands:
         - `git add <related_files> features/plans/<file_name>_plan.md` (if using separate plan files).
         - `git commit -m 'feat(<feature>): complete <file_name> with plan'`.
         - `git push origin feature/<file_name>`.
         - `gh pr create --title 'Feature: <file_name>' --body 'Auto-generated PR for <file_name>' --base main`.
       - Ensure pre-push checks (no merge conflicts, tests pass).
       - If pushing fails, log in `scratchpad.md` and pause.
    6. **Completion and Next File**:
       - The Planner confirms completion by verifying test results and success criteria in `scratchpad.md`.
       - Move to the next file in numeric order within the group or as specified (e.g., `102_next_feature.md`).
  - **Error Handling**:
    - If planning fails (e.g., unclear requirements), retry twice, then pause and log in `scratchpad.md` under Executor’s Feedback or Assistance Requests.
    - If execution or testing fails, log the specific task or test, pause, and request user intervention.
    - If pushing fails, log and pause, ensuring no forced pushes without user approval (`git -force`).

- **Task Completion**:
  - Only the Planner can confirm task completion after cross-checking Executor outputs against success criteria.
  - If the Executor believes a task is complete, it must request Planner confirmation in `scratchpad.md`.

## Documentation Conventions
- **Scratchpad Structure**:
  - Maintain the following sections in `scratchpad.md`:
    - **Background and Motivation**: Task context and goals.
    - **Key Challenges and Analysis**: Potential issues and solutions.
    - **High-level Task Breakdown**: Step-by-step tasks with success criteria.
    - **Project Status Board**: Markdown todo list (e.g., `- [ ] Task 1`, `- [x] Task 2`).
    - **Feature Plan: <file_name>**: Plan for each feature file in the Sequential File Processing Workflow, including Task Breakdown, Dependencies, and Estimated Effort (e.g., `Feature Plan: 101_login.md`).
    - **Current Status / Progress Tracking**: Executor’s progress updates.
    - **Executor’s Feedback or Assistance Requests**: Questions or blockers.
    - **Lessons**: Documented solutions to errors or reusable information.
  - Do not arbitrarily change section titles to maintain consistency.
- **Feature Plan Files (Optional)**:
  - To avoid cluttering `scratchpad.md`, create dedicated plan files in `features/plans/` (e.g., `features/plans/101_login_plan.md`) for each feature’s plan.
  - Structure:
    ```markdown
    # Plan for <file_name>
    ## Task Breakdown
    - [ ] Task 1: <description> (Success: <criteria>, Effort: <time>)
    - [ ] Task 2: <description> (Success: <criteria>, Effort: <time>, Depends: Task 1)
    ## Dependencies
    - Task 2 depends on Task 1
    ## Notes
    - Align with BuildTrack Pro’s guiding principles
    ```
  - Reference these plans in `scratchpad.md` (e.g., “See `features/plans/101_login_plan.md` for details”).
- **Documentation Practices**:
  - Avoid rewriting the entire `scratchpad.md` unless necessary; append or mark sections as outdated.
  - When external information is needed (e.g., API docs for Supabase), use the `@web` tag to fetch up-to-date documentation, then create `.md` files for reference (e.g., `docs/supabase-api.md`).
  - Document reusable information (e.g., library versions, fixes) in the Lessons section.
  - For Sequential File Processing, commit plan files (e.g., `features/plans/101_login_plan.md`) to Git for traceability.

## Project-Specific Instructions
- **Reference Materials**:
  - Always consult `project-overview.md` (updated April 25, 2025) for project goals, components (Dashboard, Admin Console, Marketing Website, CMS), and guiding principles (e.g., user-centric design, accessibility, scalability).
  - Use the 74 feature files in `features/` for detailed requirements (e.g., `features/dashboard-home.md`: “Customizable dashboard with widgets for projects, tasks, analytics, and notifications, supporting drag-and-drop functionality”).
  - Follow the technical stack in `features/tech-stack.md` (e.g., Next.js, TypeScript, Supabase, TailwindCSS).
- **File Grouping** (for Sequential File Processing):
  - Files in `features/` are themed with numeric prefixes:
    - **100s**: Core features (e.g., `101_login.md`, `102_signup.md`)
    - **200s**: Dashboard features (e.g., `201_dashboard-home.md`, `202_project-view.md`)
    - **300s**: Admin Console features (e.g., `301_user-management.md`)
    - **400s**: CMS and Marketing Website features (e.g., `401_cms-editor.md`)
  - Process in numeric order within groups, prioritizing 100s, then 200s, 300s, 400s.
- **Coding Standards**:
  - **General**:
    - Adhere to the summarized Coding Standards in `project-overview.md` and the detailed guidelines below.
    - Write clean, readable, and maintainable code following the principles of DRY (Don’t Repeat Yourself) and KISS (Keep It Simple, Stupid).
    - **Simplify Code Structure**:
      - Break down complex functions into smaller, single-responsibility functions (e.g., instead of one large `handleFormSubmit`, create `validateForm`, `saveFormData`, and `updateUI`).
      - Limit functions to a maximum of 15 lines; if longer, refactor into smaller functions.
      - Avoid nested conditionals by using early returns (e.g., `if (!condition) return; doSomething();` instead of `if (condition) { ... }`).
      - Use simple data structures when possible (e.g., prefer a flat array over a nested object unless the nesting is necessary).
    - Use meaningful variable and function names that reflect their purpose (e.g., `fetchProjectData` instead of `getData`).
    - Limit line length to 80 characters for readability; use Prettier to enforce formatting.
    - Use 2-space indentation for all code files.
  - **TypeScript**:
    - Use TypeScript in strict mode to catch errors early (`"strict": true` in `tsconfig.json`).
    - Prefer interfaces over types for defining object shapes (e.g., `interface Project { id: string; name: string; }').
    - Always define explicit return types for functions (e.g., `function getProject(id: string): Promise<Project>`).
    - Avoid using `any` unless absolutely necessary; prefer `unknown` and type guards for safer type handling.
    - Use type inference where possible to reduce boilerplate (e.g., `const projectId = "123";` instead of `const projectId: string = "123";`).
    - **Simplify Type Definitions**:
      - Avoid over-typing; rely on TypeScript’s inference for simple cases (e.g., don’t type array literals like `const ids: string[] = ["1", "2"]` when `const ids = ["1", "2"]` suffices).
      - Use union types or optional properties instead of creating complex nested types when possible (e.g., `status: "active" | "inactive"` instead of separate interfaces for each status).
  - **React/Next.js**:
    - Use functional components with hooks (e.g., `useState`, `useEffect`) instead of class components.
    - Organize components by feature (e.g., `components/dashboard/ProjectWidget.tsx`, `components/admin/UserTable.tsx`).
    - **Simplify Components**:
      - Keep components small and focused; if a component exceeds 100 lines, refactor it into smaller sub-components.
      - Extract reusable logic into custom hooks (e.g., `useProjectData` instead of repeating fetch logic in multiple components).
      - Avoid deeply nested JSX; use helper components or fragments to flatten the structure.
    - Use Next.js API routes for backend logic (e.g., `/pages/api/projects.ts` for fetching project data).
    - Implement static generation (`getStaticProps`) or server-side rendering (`getServerSideProps`) for pages where applicable to optimize performance.
    - Use React’s Context API or a lightweight state management library (e.g., Zustand) for global state, avoiding prop drilling.
  - **Styling**:
    - Use TailwindCSS for all styling, following its utility-first approach.
    - Group related Tailwind classes logically (e.g., `className="flex flex-col gap-4 p-4 bg-gray-100"`).
    - Avoid inline styles unless necessary for dynamic values (e.g., `style={{ width: `${progress}%` }}`).
    - **Simplify Styling**:
      - Use Tailwind’s utility classes to reduce CSS complexity; avoid writing custom CSS unless Tailwind cannot achieve the desired style.
      - Keep class names concise by leveraging Tailwind’s shorthand (e.g., `p-4` instead of `padding: 1rem`).
    - Ensure responsive design using Tailwind’s responsive prefixes (e.g., `md:flex-row` for medium screens and up).
  - **Database (Supabase)**:
    - Use Supabase’s TypeScript client (`@supabase/supabase-js`) for all database interactions.
    - Define database types in a central location (e.g., `types/database.ts`) using Supabase’s generated types (via `supabase typegen`).
    - Follow RESTful conventions for API endpoints (e.g., `GET /api/projects` for fetching projects, `POST /api/projects` for creating a project).
    - Implement row-level security (RLS) in Supabase to ensure data access is restricted to authorized users.
  - **Error Handling**:
    - Use try-catch blocks for asynchronous operations (e.g., `try { await supabase.from('projects').select('*'); } catch (error) { console.error('Error fetching projects:', error); }`).
    - Provide user-friendly error messages in the UI (e.g., “Unable to load projects. Please try again later.”).
    - Log errors to the console and document them in `scratchpad.md` under Executor’s Feedback or Assistance Requests.
  - **Testing**:
    - Adopt Test-Driven Development (TDD): Write tests before implementation using Vitest for unit tests and Playwright for end-to-end tests.
    - Name tests descriptively (e.g., `should render ProjectWidget with project data`).
    - Aim for at least 80% test coverage for critical components (e.g., Dashboard widgets, API routes).
    - Test accessibility using Playwright’s axe integration to ensure WCAG 2.1 AA compliance.
  - **File Structure**:
    - Group files by feature (e.g., `components/dashboard/`, `pages/api/projects/`, `lib/supabase/`).
    - Use lowercase with hyphens for file names (e.g., `project-widget.tsx`, `fetch-projects.ts`).
    - Maintain a `types/` directory for TypeScript types and interfaces (e.g., `types/project.ts`).
  - **Git Practices**:
    - Write descriptive commit messages following the Conventional Commits format (e.g., `feat(dashboard): add project widget drag-and-drop`).
    - Use feature branches for development (e.g., `feature/dashboard-widget`).
    - Create pull requests for code reviews, ensuring at least one approval before merging to `main`.
    - For Sequential File Processing, commit feature code and plan files with each push.

## Implementation Phases
- **Phase 1: Core Features** (Dashboard, Authentication, Basic Admin Console):
  - Focus on user-facing features like the Dashboard and authentication to establish the core user journey.
  - Example task: “Implement Dashboard Home; success criteria: widgets are draggable and persist state.”
- **Phase 2: Secondary Features** (Marketing Website, CMS, Advanced Admin Console):
  - Enhance functionality with marketing pages, content management, and advanced admin tools.
  - Example task: “Implement CMS for Marketing Website; success criteria: users can edit and publish landing pages.”
- **Phase 3: Integrations and Scalability** (Third-Party APIs, Performanceинь Optimization):
  - Add integrations (e.g., payment gateways, analytics) and optimize for scale.
  - Example task: “Integrate Stripe for payments; success criteria: users can subscribe to plans.”
- **Phase 4: Future Expansions** (Mobile App Support, Advanced Analytics):
  - Plan for future growth while maintaining core functionality.
  - Example task: “Plan mobile app support; success criteria: draft a feature spec for responsive design.”

## Debugging and Error Handling
- **Error Detection**:
  - Check the console for error messages and report them in `scratchpad.md` under Executor’s Feedback or Assistance Requests.
  - Include debugging information in program output (e.g., logs for API failures).
- **Error Resolution**:
  - Revert to the last working checkpoint if an error persists, using the “Restore checkpoint” feature.
  - Rethink the prompt, asking for missing information (e.g., “What do you need to feel 100% confident you can implement this?”).
  - If stuck, simplify the scope and restart the planning process in Planner Mode.
- **Lessons Learned**:
  - Document solutions to errors in the Lessons section of `scratchpad.md` (e.g., “Adjusted Supabase query to handle pagination”).
  - Follow user-specified lessons: Read files before editing, run `npm audit` if vulnerabilities appear, ask before using `git -force`.

## Additional Guidelines
- **Communication**:
  - If unsure, prompt the user for clarification (e.g., “Do you want to invoke the Sequential File Processing Workflow or a general task?”).
  - Do not proceed with actions you’re not 100% confident about, as the user is non-technical.
- **Large-Scale Changes**:
  - Before executing large-scale changes, the Executor must notify the Planner in `scratchpad.md` to ensure alignment.
- **Project Completion**:
  - The Planner will indicate when the project is complete, based on the goals in `project-overview.md` and the 74 feature files.

## User-Specified Lessons
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- If there are vulnerabilities that appear in the terminal, run `npm audit` before proceeding.
- Always ask before using the `-force` git command.