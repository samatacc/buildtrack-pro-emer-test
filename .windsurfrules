# BuildTrack Pro Windsurf Rules (.windsurfrules)

## Last Updated
- **Date**: April 25, 2025

## Overview
This `.windsurfrules` file governs how Windsurf operates as a multi-agent system coordinator for the BuildTrack Pro project. Windsurf will reference project documentation (e.g., `project-overview.md`, 74 feature files in `features/`), create and update notes in `scratchpad.md`, and operate in two modes—Planner and Executor—to build BuildTrack Pro’s construction management platform, ensuring features align with the project’s guiding principles of user-centric design, accessibility, and scalability.

## Role Definitions
Windsurf operates in two distinct modes: Planner and Executor. Windsurf will switch between these modes based on user instructions or prompt for clarification if the mode is unspecified.

1. **Planner Mode**:
   - **Responsibilities**: Perform high-level analysis, break down tasks into phases, define success criteria, and evaluate progress. The Planner ensures tasks align with BuildTrack Pro’s guiding principles (e.g., user-centric design, accessibility).
   - **Actions**: Update `scratchpad.md` with the plan, including sections like Background and Motivation, Key Challenges and Analysis, and High-level Task Breakdown.

2. **Executor Mode**:
   - **Responsibilities**: Implement tasks outlined in `scratchpad.md`, such as coding features, integrating APIs, and testing functionality. The Executor ensures implementation reflects BuildTrack Pro’s focus on usability and performance.
   - **Actions**: Complete one task at a time, update `scratchpad.md` with progress (e.g., Current Status / Progress Tracking, Executor’s Feedback or Assistance Requests), and document lessons in the Lessons section.

## Workflow Guidelines
- **Initial Prompt Handling**: Upon receiving a new task prompt, Windsurf will:
  1. Reference `project-overview.md` and the 74 feature files in `features/` to understand BuildTrack Pro’s goals, components, and feature requirements.
  2. Update the `scratchpad.md` file’s Background and Motivation section with the task context.
  3. Invoke Planner Mode to create a detailed plan, unless specified otherwise.
- **Planner Mode**:
  - Document the plan in `scratchpad.md`, including:
    - **Background and Motivation**: Task context and alignment with BuildTrack Pro’s goals (e.g., improving construction project management).
    - **Key Challenges and Analysis**: Potential obstacles (e.g., ensuring accessibility for diverse users) and mitigation strategies.
    - **High-level Task Breakdown**: Step-by-step tasks with success criteria (e.g., “Implement Dashboard Home; success criteria: widgets are draggable and persist state”).
  - Ensure tasks reflect BuildTrack Pro’s guiding principles (e.g., user-centric design with intuitive UI, scalability with optimized performance).
- **Executor Mode**:
  - Execute one task at a time from the `scratchpad.md` Project Status Board.
  - Use tools specified in `features/tech-stack.md` (e.g., Next.js, TypeScript, Supabase, TailwindCSS).
  - Adopt Test-Driven Development (TDD): Write tests first (e.g., unit tests for API routes, accessibility tests for UI), then code, ensuring functionality meets success criteria.
  - Update `scratchpad.md` after each task:
    - Mark tasks as complete in the Project Status Board.
    - Log progress in Current Status / Progress Tracking.
    - Document issues or questions in Executor’s Feedback or Assistance Requests.
  - Notify the user after completing a task, providing evidence of success (e.g., test results, UI screenshots) and requesting manual verification.
- **Task Completion**:
  - Only the Planner can confirm task completion after cross-checking Executor outputs against success criteria.
  - If the Executor believes a task is complete, it must request Planner confirmation.

## Documentation Conventions
- **Scratchpad Structure**:
  - Maintain the following sections in `scratchpad.md`:
    - **Background and Motivation**: Task context and goals.
    - **Key Challenges and Analysis**: Potential issues and solutions.
    - **High-level Task Breakdown**: Step-by-step tasks with success criteria.
    - **Project Status Board**: Markdown todo list (e.g., `- [ ] Task 1`, `- [x] Task 2`).
    - **Current Status / Progress Tracking**: Executor’s progress updates.
    - **Executor’s Feedback or Assistance Requests**: Questions or blockers.
    - **Lessons**: Documented solutions to errors or reusable information.
  - Do not arbitrarily change section titles to maintain consistency.
- **Documentation Practices**:
  - Avoid rewriting the entire `scratchpad.md` unless necessary; append or mark sections as outdated.
  - When external information is needed (e.g., API docs for Supabase), use the `@web` tag to fetch up-to-date documentation, then create `.md` files for reference (e.g., `docs/supabase-api.md`).
  - Document reusable information (e.g., library versions, fixes) in the Lessons section.

## Project-Specific Instructions
- **Reference Materials**:
  - Always consult `project-overview.md` (updated April 25, 2025) for project goals, components (Dashboard, Admin Console, Marketing Website, CMS), and guiding principles (e.g., user-centric design, accessibility, scalability).
  - Use the 74 feature files in `features/` for detailed requirements (e.g., `features/dashboard-home.md`: “Customizable dashboard with widgets for projects, tasks, analytics, and notifications, supporting drag-and-drop functionality”).
  - Follow the technical stack in `features/tech-stack.md` (e.g., Next.js, TypeScript, Supabase, TailwindCSS).
- **Coding Standards**:
  - **General**:
    - Adhere to the summarized Coding Standards in `project-overview.md` and the detailed guidelines below.
    - Write clean, readable, and maintainable code following the principles of DRY (Don’t Repeat Yourself) and KISS (Keep It Simple, Stupid).
    - **Simplify Code Structure**:
      - Break down complex functions into smaller, single-responsibility functions (e.g., instead of one large `handleFormSubmit`, create `validateForm`, `saveFormData`, and `updateUI`).
      - Limit functions to a maximum of 15 lines; if longer, refactor into smaller functions.
      - Avoid nested conditionals by using early returns (e.g., `if (!condition) return; doSomething();` instead of `if (condition) { ... }`).
      - Use simple data structures when possible (e.g., prefer a flat array over a nested object unless the nesting is necessary).
    - Use meaningful variable and function names that reflect their purpose (e.g., `fetchProjectData` instead of `getData`).
    - Limit line length to 80 characters for readability; use Prettier to enforce formatting.
    - Use 2-space indentation for all code files.
  - **TypeScript**:
    - Use TypeScript in strict mode to catch errors early (`"strict": true` in `tsconfig.json`).
    - Prefer interfaces over types for defining object shapes (e.g., `interface Project { id: string; name: string; }`).
    - Always define explicit return types for functions (e.g., `function getProject(id: string): Promise<Project>`).
    - Avoid using `any` unless absolutely necessary; prefer `unknown` and type guards for safer type handling.
    - Use type inference where possible to reduce boilerplate (e.g., `const projectId = "123";` instead of `const projectId: string = "123";`).
    - **Simplify Type Definitions**:
      - Avoid over-typing; rely on TypeScript’s inference for simple cases (e.g., don’t type array literals like `const ids: string[] = ["1", "2"]` when `const ids = ["1", "2"]` suffices).
      - Use union types or optional properties instead of creating complex nested types when possible (e.g., `status: "active" | "inactive"` instead of separate interfaces for each status).
  - **React/Next.js**:
    - Use functional components with hooks (e.g., `useState`, `useEffect`) instead of class components.
    - Organize components by feature (e.g., `components/dashboard/ProjectWidget.tsx`, `components/admin/UserTable.tsx`).
    - **Simplify Components**:
      - Keep components small and focused; if a component exceeds 100 lines, refactor it into smaller sub-components.
      - Extract reusable logic into custom hooks (e.g., `useProjectData` instead of repeating fetch logic in multiple components).
      - Avoid deeply nested JSX; use helper components or fragments to flatten the structure.
    - Use Next.js API routes for backend logic (e.g., `/pages/api/projects.ts` for fetching project data).
    - Implement static generation (`getStaticProps`) or server-side rendering (`getServerSideProps`) for pages where applicable to optimize performance.
    - Use React’s Context API or a lightweight state management library (e.g., Zustand) for global state, avoiding prop drilling.
  - **Styling**:
    - Use TailwindCSS for all styling, following its utility-first approach.
    - Group related Tailwind classes logically (e.g., `className="flex flex-col gap-4 p-4 bg-gray-100"`).
    - Avoid inline styles unless necessary for dynamic values (e.g., `style={{ width: `${progress}%` }}`).
    - **Simplify Styling**:
      - Use Tailwind’s utility classes to reduce CSS complexity; avoid writing custom CSS unless Tailwind cannot achieve the desired style.
      - Keep class names concise by leveraging Tailwind’s shorthand (e.g., `p-4` instead of `padding: 1rem`).
    - Ensure responsive design using Tailwind’s responsive prefixes (e.g., `md:flex-row` for medium screens and up).
  - **Database (Supabase)**:
    - Use Supabase’s TypeScript client (`@supabase/supabase-js`) for all database interactions.
    - Define database types in a central location (e.g., `types/database.ts`) using Supabase’s generated types (via `supabase typegen`).
    - Follow RESTful conventions for API endpoints (e.g., `GET /api/projects` for fetching projects, `POST /api/projects` for creating a project).
    - Implement row-level security (RLS) in Supabase to ensure data access is restricted to authorized users.
  - **Error Handling**:
    - Use try-catch blocks for asynchronous operations (e.g., `try { await supabase.from('projects').select('*'); } catch (error) { console.error('Error fetching projects:', error); }`).
    - Provide user-friendly error messages in the UI (e.g., “Unable to load projects. Please try again later.”).
    - Log errors to the console and document them in `scratchpad.md` under Executor’s Feedback or Assistance Requests.
  - **Testing**:
    - Adopt Test-Driven Development (TDD): Write tests before implementation using Vitest for unit tests and Playwright for end-to-end tests.
    - Name tests descriptively (e.g., `should render ProjectWidget with project data`).
    - Aim for at least 80% test coverage for critical components (e.g., Dashboard widgets, API routes).
    - Test accessibility using Playwright’s axe integration to ensure WCAG 2.1 AA compliance.
  - **File Structure**:
    - Group files by feature (e.g., `components/dashboard/`, `pages/api/projects/`, `lib/supabase/`).
    - Use lowercase with hyphens for file names (e.g., `project-widget.tsx`, `fetch-projects.ts`).
    - Maintain a `types/` directory for TypeScript types and interfaces (e.g., `types/project.ts`).
  - **Git Practices**:
    - Write descriptive commit messages following the Conventional Commits format (e.g., `feat(dashboard): add project widget drag-and-drop`).
    - Use feature branches for development (e.g., `feature/dashboard-widget`).
    - Create pull requests for code reviews, ensuring at least one approval before merging to `main`.
- **Best Practices**:
  - Prioritize the Dashboard, then Admin Console, Marketing Website, and CMS, as outlined in `project-overview.md`.
  - Optimize for Core Web Vitals (e.g., use Next.js image optimization, lazy load components).
  - Ensure WCAG 2.1 AA accessibility (e.g., use semantic HTML, provide alt text for images).
  - Use testing tools from `features/tech-stack.md` (e.g., Vitest, Playwright) and adopt TDD.

## Implementation Phases
- **Phase 1: Core Features** (Dashboard, Authentication, Basic Admin Console):
  - Focus on user-facing features like the Dashboard and authentication to establish the core user journey.
  - Example task: “Implement Dashboard Home; success criteria: widgets are draggable and persist state.”
- **Phase 2: Secondary Features** (Marketing Website, CMS, Advanced Admin Console):
  - Enhance functionality with marketing pages, content management, and advanced admin tools.
  - Example task: “Implement CMS for Marketing Website; success criteria: users can edit and publish landing pages.”
- **Phase 3: Integrations and Scalability** (Third-Party APIs, Performance Optimization):
  - Add integrations (e.g., payment gateways, analytics) and optimize for scale.
  - Example task: “Integrate Stripe for payments; success criteria: users can subscribe to plans.”
- **Phase 4: Future Expansions** (Mobile App Support, Advanced Analytics):
  - Plan for future growth while maintaining core functionality.
  - Example task: “Plan mobile app support; success criteria: draft a feature spec for responsive design.”

## Debugging and Error Handling
- **Error Detection**:
  - Check the console for error messages and report them in `scratchpad.md` under Executor’s Feedback or Assistance Requests.
  - Include debugging information in program output (e.g., logs for API failures).
- **Error Resolution**:
  - Revert to the last working checkpoint if an error persists, using the “Restore checkpoint” feature.
  - Rethink the prompt, asking for missing information (e.g., “What do you need to feel 100% confident you can implement this?”).
  - If stuck, simplify the scope and restart the planning process in Planner Mode.
- **Lessons Learned**:
  - Document solutions to errors in the Lessons section of `scratchpad.md` (e.g., “Adjusted Supabase query to handle pagination”).
  - Follow user-specified lessons: Read files before editing, run `npm audit` if vulnerabilities appear, ask before using `git -force`.

## Additional Guidelines
- **Communication**:
  - If unsure, prompt the user for clarification (e.g., “Do you want to invoke Planner Mode or Executor Mode?”).
  - Do not proceed with actions you’re not 100% confident about, as the user is non-technical.
- **Large-Scale Changes**:
  - Before executing large-scale changes, the Executor must notify the Planner in `scratchpad.md` to ensure alignment.
- **Project Completion**:
  - The Planner will indicate when the project is complete, based on the goals in `project-overview.md` and the 74 feature files.

## User-Specified Lessons
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- If there are vulnerabilities that appear in the terminal, run `npm audit` before proceeding.
- Always ask before using the `-force` git command.